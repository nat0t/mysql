Составить общее текстовое описание БД и решаемых ею задач;
минимальное количество таблиц - 10;
скрипты создания структуры БД (с первичными ключами, индексами, внешними ключами);
создать ERDiagram для БД;
скрипты наполнения БД данными;
скрипты характерных выборок (включающие группировки, JOIN'ы, вложенные таблицы);
представления (минимум 2);
хранимые процедуры / триггеры;
_______________________________________________________________________________________________________________________________________________

В курсовом проекте представлена модель базы данных типового интернет-магазина. В качестве источника для создания модели использован сайт сети магазинов "Ситилинк": https://www.citilink.ru. Обращаю внимание на тот факт, что сайт обладает обширнейшим функционалом и весь он отражен в БД не будет.

В приложенном файле clink_tables_old.sql находятся изначальные скрипты создания таблиц.
В файле clink_tables.sql находятся скрипты создания таблиц, полученные с помощью команды SHOW CREATE TABLE, уже после корректировок и заполнения БД.
В файле ERDiagram.png содержится ER-диаграмма БД.
В файле clink.sql содержится итоговый дамп БД.

Цель сайта: демонстрация товаров и услуг с целью возбуждения у посетителей интереса и желания купить продукт.
Задачи, решаемые с помощью БД:
- показывать посетителю информацию о товаре;
- предоставлять описания и свойства товара в структурированных категориях;
- дать посетителю возможность производить поиск товаров в названиях, марках и категориях путем задания ключевых слов;
- автоматизировать систему приема заказов;
- позволять клиентам оплачивать заказы;
- организовывать и проводить доставку товаров клиентам.

Типичные запросы к данной базе данных:
- вывод определенных товаров по различным критериям;
- вывод всей номенклатуры товаров в зависимости от цен;
- вывод товаров из таблицы заказов по определенным критериям (н-р цене);
- объединение таблиц по различным критериям;
- вывод информации о доставках по определенной дате/производителю/товару и т.д.;
- вывод финансовой информции на основании счетов.

SELECT products.name,
	product_descriptions.name AS description
FROM products
	LEFT JOIN product_descriptions
		ON products.description_id = product_descriptions.id
	JOIN manufacturers
		ON products.manufacturer_id = manufacturers.id
	JOIN categories
		ON products.category_id = categories.id
WHERE categories.name = 'autem' AND manufacturers.name = 'delectus'
ORDER BY products.name;

SELECT products.name,
	product_descriptions.name AS description,
	categories.name AS category,
	manufacturers.name AS manufacturer,
	products.qty AS quantity,
	products.price
FROM products
	JOIN product_descriptions
		ON products.description_id = product_descriptions.id
	JOIN categories
		ON products.category_id = categories.id
	JOIN manufacturers
		ON products.manufacturer_id = manufacturers.id
WHERE products.price >= 20000
ORDER BY products.price DESC;

SELECT *
FROM products
WHERE id IN (SELECT product_id FROM order_items)
	AND price > (SELECT AVG(price) FROM products);

(SELECT name FROM products WHERE category_id = 2)
UNION
(SELECT name FROM products WHERE manufacturer_id = 3)
ORDER BY name;

SELECT products.name,
	orders.cost,
	order_items.qty
FROM products
	JOIN order_items
		ON order_items.product_id = products.id
	JOIN orders
		ON orders.id = order_items.order_id
	JOIN deliveries
		ON deliveries.order_id = orders.id AND deliveries.delivery_date LIKE '2019-%';

SELECT manufacturers.name,
	order_items.qty
FROM manufacturers
	JOIN products
		ON products.manufacturer_id = manufacturers.id
	JOIN order_items
		ON order_items.product_id = products.id
	JOIN invoices
		ON invoices.order_id = order_items.order_id
	JOIN invoice_statuses
		ON invoice_statuses.id = invoices.invoice_status_id AND invoice_statuses.description = 'fully invoiced';

Представления можно использовать для предоставления ограниченного доступа к чувствительной информации (н-р, финансовая информация или личные данные):
CREATE VIEW clients_20_40 AS
SELECT first_name, last_name, email
FROM clients
WHERE (YEAR(NOW())-YEAR(birthday) BETWEEN 20 AND 40) AND organisation = 0
ORDER BY last_name;

CREATE VIEW orders_cost_last_month AS
SELECT SUM(cost)
FROM orders
WHERE TO_DAYS(NOW()) - TO_DAYS(created_at) <= 30;

Также можно использовать представления для структурирования запрошенных/изменяемых данных:

CREATE VIEW products_for_delivery AS
SELECT DISTINCT products.name,
	deliveries.tracking_number,
	deliveries.delivery_date
FROM products
	JOIN order_items
		ON order_items.product_id = products.id
	JOIN deliveries
		ON deliveries.order_id = order_items.order_id
ORDER BY products.name;

Триггеры зачастую используются для логгирования операций над некоторыми важными таблицами:

DELIMITER //

DROP TRIGGER IF EXISTS log_client_payment_methods//
CREATE TRIGGER log_client_payment_methods AFTER UPDATE ON client_payment_methods
FOR EACH ROW
BEGIN
	INSERT INTO logs (table_name, record_id, record_target)
	VALUES ('client_payment_methods', NEW.id, NEW.account_number);
END//

DROP TRIGGER IF EXISTS log_clients//
CREATE TRIGGER log_clients AFTER INSERT ON clients
FOR EACH ROW
BEGIN
	INSERT INTO logs (table_name, record_id, record_target)
	VALUES ('clients', NEW.id, NEW.last_name);
END//

DROP TRIGGER IF EXISTS log_insert_payments//
CREATE TRIGGER log_insert_payments AFTER INSERT ON payments
FOR EACH ROW
BEGIN
	INSERT INTO logs (table_name, record_id, record_target)
	VALUES ('payments', NEW.id, NEW.amount);
END//

DROP TRIGGER IF EXISTS log_update_payments//
CREATE TRIGGER log_update_payments AFTER UPDATE ON payments
FOR EACH ROW
BEGIN
	INSERT INTO logs (table_name, record_id, record_target)
	VALUES ('payments', NEW.id, NEW.amount);
END//

DELIMITER ;
